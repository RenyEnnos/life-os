[
  {
    "projectId": "914e5778-cecd-4592-aea3-cc95857083a1",
    "testId": "8945d696-c9bd-4d06-b19c-0e5d5eed6071",
    "userId": "c4283498-d031-7065-ccf1-5b911b8483dd",
    "title": "TC002-User login fails with invalid credentials",
    "description": "Ensure the system prevents login with incorrect email or password and displays an appropriate error message.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly for the page to finish loading. If no navigation elements appear, navigate directly to http://localhost:5173/login.\n        await page.goto(\"http://localhost:5173/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Enter an invalid email and password into the form and click the ENTRAR (submit) button to trigger login validation.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Submit invalid credentials again and inspect page for an error message (look for alerts, toast messages, or body text keywords).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invalid email or password').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test attempted to verify that submitting invalid credentials prevents login and displays the error message 'Invalid email or password', but that error message did not appear.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final test result for TC002/TC010: FAILED to verify that the system displays an error message when invalid credentials are used.\n\nWhat was executed:\n- Navigated to http://localhost:5173/login (interactive login form present).\n- Entered invalid credentials into fields present on the page (email input index 799, password input index 800) and submitted the form (submit button index 803) twice as part of verification attempts.\n- Performed multiple exhaustive DOM searches (role=alert, aria-live, common toast/alert classes, visible text keywords in Portuguese/English) for any error/alert/toast nodes; no error message or alert element was found.\n\nObserved outcome:\n- After two invalid-submit attempts, the page remains on the login form. No visible error text, alert, toast, or aria-live message was detected in the DOM snapshots or programmatic scans.\n- Programmatic scans returned only form labels and controls; no error indicators were found.\n\nConclusion:\n- The application did not render a visible and detectable error message in response to invalid credentials (or the error is rendered in a way that is not discoverable by DOM queries performed, e.g., rendered off-screen, within a canvas, in an iframe not exposed, or displayed only briefly). Therefore, the automated verification step to confirm an appropriate error message failed.\n\nRecommended next steps to investigate and fix:\n1) Check browser developer console for client-side errors (JS exceptions) that may prevent error rendering.\n2) Inspect network requests for the login POST to confirm the server responds with an authentication failure (status code and response body). If the server returns an error, confirm the client-side code processes and displays it.\n3) Verify the toast/alert component implementation: ensure it appends to an accessible DOM location and uses role=alert or aria-live for assistive detection, and that it is not hidden by CSS or unmounted too quickly.\n4) Re-run the test while monitoring console and network (or instrument the app to write visible error text to a stable DOM container) to allow programmatic detection.\n5) If the error is expected to be transient, increase observation/wait time or capture console logs during the submit.\n\nSummary for the test record:\n- TC002/TC010 final verification: FAILED (error message not detected). Actions performed: navigate=1, invalid-submits=2, DOM-scans=4. Verification remaining: 0 (test concluded with failure).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4283498-d031-7065-ccf1-5b911b8483dd/1769637778294067//tmp/test_task/result.webm",
    "created": "2026-01-28T21:55:00.352Z",
    "modified": "2026-01-28T22:02:58.400Z"
  },
  {
    "projectId": "914e5778-cecd-4592-aea3-cc95857083a1",
    "testId": "c2f78f45-9eb7-413c-9902-42c6a57b2293",
    "userId": "c4283498-d031-7065-ccf1-5b911b8483dd",
    "title": "TC010-AI Assistant responds accurately and offers task creation suggestions",
    "description": "Test AI chat interface interaction including posing questions, receiving accurate answers, and AI suggesting task creation with user confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Log in using test credentials so the app loads the authenticated UI (then locate the chat/floating action button). Immediately submit the login form.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Refill the login form (email and password) and click the ENTRAR submit button to retry authentication. After submitting, wait for the authenticated UI to load and locate the floating chat/assistant button.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task successfully created').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the AI-suggested task to be created and visible in task management ('Task successfully created'), but the confirmation or task entry did not appear â€” either the AI did not suggest the task, the acceptance was not processed, or the task UI failed to display.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test run aborted - authentication did not complete. Summary of findings and diagnostics:\n\n- Outcome: FAILURE (cannot continue). The app remained on /login and did not navigate to the authenticated UI. No floating assistant/chat FAB or other interactive elements for the authenticated experience were found on the page.\n\n- Actions performed: navigated to /login (1x); ran DOM checks (2x); filled email field (example@gmail.com) twice; filled password field (password123) twice; clicked ENTRAR 2 times; waited between attempts. Total test plan steps completed: 0/6.\n\n- Observed problem: Login submission showed a loading state ('ACESSANDO...') but authentication never completed and page did not change. Current tab displays an effectively empty page with no interactive elements.\n\n- Objective failure statements: \"Authentication not confirmed - page remains on /login\"; \"Floating chat/assistant button not found on the page\"; \"No interactive elements available to continue test steps.\" \n\n- Recommended next steps for investigators or retrying the test:\n  1) Verify the backend authentication service is running and reachable from the frontend. Check network/API responses when clicking ENTRAR. 2) Confirm the frontend assets and SPA are fully built/served (inspect browser console and network for 404/500 or missing JS bundles). 3) Retry the login flow manually in a browser to observe UI/console/network errors, then re-run the automated test after fixing the root cause. 4) If additional login attempts should be allowed in the test, increase allowed attempts or provide alternate test credentials.\n\nBecause authentication did not succeed and the authenticated UI (with the chat FAB) never loaded, the remaining test steps (opening chat, sending query, verifying AI response, accepting task creation, and verifying created task) cannot be executed. End of run.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4283498-d031-7065-ccf1-5b911b8483dd/176963748746124//tmp/test_task/result.webm",
    "created": "2026-01-28T21:55:00.363Z",
    "modified": "2026-01-28T21:58:07.574Z"
  }
]
