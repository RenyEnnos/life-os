[
  {
    "projectId": "52dc9d32-45d3-41db-822f-d7bc3558b812",
    "testId": "28d710bf-d174-43ca-ad10-54985f55ed43",
    "userId": "c4283498-d031-7065-ccf1-5b911b8483dd",
    "title": "TC002-User login fails with invalid credentials",
    "description": "Ensure the system prevents login with incorrect email or password and displays an appropriate error message.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Navigate directly to the login page (http://localhost:5173/login) to load the login form so invalid-credentials test can be executed.\n        await page.goto(\"http://localhost:5173/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Try to recover the login page by waiting briefly then navigating to the hash-based login URL (http://localhost:5173/#/login). If that fails, try other variants or report issue.\n        await page.goto(\"http://localhost:5173/#/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Wait briefly then attempt loading the login page using the alternate host URL (http://127.0.0.1:5173/login) to locate the login form and interactive fields.\n        await page.goto(\"http://127.0.0.1:5173/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Load the hash-based login route at http://127.0.0.1:5173/#/login to locate the login form.\n        await page.goto(\"http://127.0.0.1:5173/#/login\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Enter invalid email and password into the login form, then click the ENTRAR button to attempt login (next page state will be checked for error message).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrong.user@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('incorrectPassword123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password fields again with invalid credentials and click the ENTRAR button to produce and capture the Portuguese error message.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrong.user@example.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('incorrectPassword123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=E-mail ou senha inválidos').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test verified that the system rejects login with incorrect email/password and displays the Portuguese error message 'E-mail ou senha inválidos', but that error message did not appear\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test summary for: ensure incorrect login prevented and Portuguese error displayed\n\nWhat was done:\n- Reached and inspected the login page (LIFE OS - Acesso ao Sistema). Inputs: email (index 1066) and password (index 1067). Submit button: index 1070.\n- Performed two invalid-login attempts using wrong credentials. Each submission showed a loading state but the page returned to the login form.\n- Performed multiple DOM/evaluate scans (including deep scans for toast/alert/aria-live/role=alert elements) and searched for Portuguese error keywords (inválido, incorreto, credenciais, senha, Acesso negado, não autorizado, etc.). No error message in Portuguese was found. The page body remained the login form text.\n- Observed one HTML5 validation text in a snapshot: 'Please fill out this field.' (likely browser validation when inputs empty).\n\nResult:\n- Verification FAILED: No visible Portuguese error message confirming rejection of invalid credentials was captured.\n- Possible causes: the application shows the error as a transient toast that was not present in the captured DOM, the error is rendered outside accessible DOM regions, or errors are displayed only in a non-aria-live manner that the test did not capture.\n\nRecommendations / next steps:\n1) Enable network or console logging to capture server response and message shown on failed login (to confirm server rejects credentials and returns a message). 2) Modify the app (or ask devs) to expose error messages in an accessible/static DOM region (role=alert or aria-live) so automated tests can reliably detect them. 3) Allow a third automated submission attempt with a small delay and continuous DOM polling to capture transient toast messages. 4) If needed, provide guidance to the test environment to keep transient UI elements visible longer for automated capture.\n\nConclusion: The system may be preventing login server-side (unknown) but automated verification of a Portuguese error message could not be completed due to absence of any captured error text. Test status: FAIL (verification incomplete).",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4283498-d031-7065-ccf1-5b911b8483dd/1769637188360411//tmp/test_task/result.webm",
    "created": "2026-01-28T21:44:56.042Z",
    "modified": "2026-01-28T21:53:08.488Z"
  },
  {
    "projectId": "52dc9d32-45d3-41db-822f-d7bc3558b812",
    "testId": "a0d010ba-fecc-4433-85e4-c3b00e2fd038",
    "userId": "c4283498-d031-7065-ccf1-5b911b8483dd",
    "title": "TC010-AI Assistant responds accurately and offers task creation suggestions",
    "description": "Test AI chat interface interaction including posing questions, receiving accurate answers, and AI suggesting task creation with user confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:5173\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Fill the login form with test credentials and submit to access the app (email -> [89], password -> [102], click submit [108]).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill email [226] with example@gmail.com, fill password [239] with password123, then click submit button [245] to log in.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the login form (email into input [322], password into input [323]) and click the submit button [326] to sign in, then wait for the dashboard to load.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Clear and re-enter email and password via shadow inputs [603] and [604], click submit [607], wait 3 seconds, then re-scan page for the assistant FAB or dashboard load.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Fill the email and password into the visible inputs (indexes 770 and 771) and click the submit button (index 774), then wait and re-scan for the floating assistant FAB or dashboard load.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@gmail.com')\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/div/div[2]/form/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Final test report:\n\nSummary of results:\n- Objective: Test AI chat interface interaction (open assistant FAB, send query, verify response, accept suggested task creation, verify task created). User requested to stop after test.\n- Outcome: FAILED — the application remained on the login page and the dashboard (and floating AI assistant) was not reached, preventing further test steps.\n\nWhat was observed:\n- Current URL: http://localhost:5173/login\n- Login UI visible; submit button displayed 'ACESSANDO...' after attempts (screenshot captured showing this state).\n- Inputs appear filled but SPA did not proceed: email and password values present in inputs, yet page remained at /login.\n- Floating AI assistant (FAB) not present on page; cannot open chat.\n- Earlier validation message seen in prior scans: 'Por favor, insira um e-mail válido.' at times, indicating possible client-side validation or input event issues.\n\nActions performed (detailed):\n- Email entered: 4 times (example@gmail.com).\n- Password entered: 4 times (password123).\n- Submit button clicked: 4 times.\n- JavaScript form submit attempted: 1 time.\n- Multiple DOM scans/evaluations executed to inspect page state.\n- Attempts used different element indexes (shadow inputs) to ensure coverage.\n\nWhy the test failed (objective statements):\n- Login did not complete — authentication flow did not navigate to the dashboard.\n- Floating assistant FAB not found on any scanned page.\n- Input events may not be reaching the SPA (inputs show values but SPA validation/handlers did not trigger navigation).\n\nRecommended next steps to troubleshoot (practical, objective):\n1) Verify backend/auth service availability and logs for received authentication requests to ensure credentials reached the server.\n2) Check frontend console and network logs for JavaScript errors, failed XHR/fetch requests, or CORS issues that block SPA initialization.\n3) Confirm client-side validation/formatting for the email field (some runs indicated 'Por favor, insira um e-mail válido.'). Ensure programmatic input dispatch triggers the same events as manual typing.\n4) Try manual login in a real browser to confirm whether the problem is environment-specific (headless/automation differences) or general.\n5) If access to a test account or different credentials is available, attempt alternate credentials.\n6) Once dashboard loads, re-run the test plan: open FAB -> send query -> verify response -> accept suggested task -> verify task created.\n\nTest artifacts and state at stop:\n- 0 of 6 test steps completed.\n- TC002 and TC010: Could not be validated (expected PASS) — marked as FAIL due to inability to reach dashboard.\n- Current page screenshot shows login state with 'ACESSANDO...'.\n\nConclusion: Testing cannot proceed because authentication did not complete and the AI assistant is not available. Stopping per user request. For reattempt, backend/frontend logs and console/network traces should be gathered and the login flow stabilized before running the assistant test cases again.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4283498-d031-7065-ccf1-5b911b8483dd/1769637154584174//tmp/test_task/result.webm",
    "created": "2026-01-28T21:44:56.047Z",
    "modified": "2026-01-28T21:52:34.747Z"
  }
]
